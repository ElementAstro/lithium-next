/*
 * switch_persistence.cpp
 *
 * Copyright (C) 2023-2024 Max Qian <lightapt.com>
 */

/*************************************************

Date: 2025-6-16

Description: INDI Switch Persistence - State Persistence Implementation

*************************************************/

#include "switch_persistence.hpp"
#include "switch_client.hpp"

#include <spdlog/spdlog.h>
#include <filesystem>
#include <fstream>

SwitchPersistence::SwitchPersistence(INDISwitchClient* client)
    : client_(client) {}

// State persistence
auto SwitchPersistence::saveState() -> bool {
    std::scoped_lock lock(persistence_mutex_);
    try {
        auto switchManager = client_->getSwitchManager();
        if (!switchManager) {
            spdlog::error("[SwitchPersistence] Switch manager not available");
            return false;
        }
        const auto& switches = switchManager->getAllSwitches();
        spdlog::info(
            "[SwitchPersistence] Saving switch states to persistent storage");
        for (size_t i = 0; i < switches.size(); ++i) {
            const auto& switchInfo = switches[i];
            auto state =
                switchManager->getSwitchState(static_cast<uint32_t>(i));
            spdlog::debug("[SwitchPersistence] Switch {}: state={}, power={}",
                          switchInfo.name,
                          (state && *state == SwitchState::ON ? "ON" : "OFF"),
                          switchInfo.powerConsumption);
        }
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to save state: {}",
                      ex.what());
        return false;
    }
}

auto SwitchPersistence::loadState() -> bool {
    std::scoped_lock lock(persistence_mutex_);
    try {
        auto switchManager = client_->getSwitchManager();
        if (!switchManager) {
            spdlog::error("[SwitchPersistence] Switch manager not available");
            return false;
        }
        spdlog::info(
            "[SwitchPersistence] Loading switch states from persistent "
            "storage");
        const auto& switches = switchManager->getAllSwitches();
        for (size_t i = 0; i < switches.size(); ++i) {
            if (!switchManager->setSwitchState(static_cast<uint32_t>(i),
                                               SwitchState::OFF)) {
                spdlog::warn(
                    "[SwitchPersistence] Failed to set state for switch {}", i);
            }
        }
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to load state: {}",
                      ex.what());
        return false;
    }
}

auto SwitchPersistence::resetToDefaults() -> bool {
    std::scoped_lock lock(persistence_mutex_);
    try {
        auto switchManager = client_->getSwitchManager();
        auto powerManager = client_->getPowerManager();
        auto safetyManager = client_->getSafetyManager();
        auto statsManager = client_->getStatsManager();
        if (!switchManager) {
            spdlog::error("[SwitchPersistence] Switch manager not available");
            return false;
        }
        [[maybe_unused]] bool allSwitchesResult =
            switchManager->setAllSwitches(SwitchState::OFF);
        if (powerManager) {
            powerManager->setPowerLimit(1000.0);
        }
        if (safetyManager) {
            [[maybe_unused]] bool safetyModeResult =
                safetyManager->enableSafetyMode(false);
            [[maybe_unused]] bool clearEmergencyResult =
                safetyManager->clearEmergencyStop();
        }
        if (statsManager) {
            statsManager->resetStatistics();
        }
        spdlog::info("[SwitchPersistence] Reset all components to defaults");
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to reset to defaults: {}",
                      ex.what());
        return false;
    }
}

// Configuration management
auto SwitchPersistence::saveConfiguration(const std::string& filename) -> bool {
    std::scoped_lock lock(persistence_mutex_);
    try {
        // Create backup if file exists
        if (std::filesystem::exists(filename)) {
            createBackup(filename);
        }
        // In a real implementation, this would save configuration to JSON/XML
        std::ofstream file(filename);
        if (!file.is_open()) {
            spdlog::error(
                "[SwitchPersistence] Failed to open file for writing: {}",
                filename);
            return false;
        }
        file << "# Switch Configuration\n";
        file << "# Generated by Lithium INDI Switch Client\n";
        file << "# Date: "
             << std::chrono::system_clock::now().time_since_epoch().count()
             << "\n";
        file.close();
        spdlog::info("[SwitchPersistence] Configuration saved to: {}",
                     filename);
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to save configuration: {}",
                      ex.what());
        return false;
    }
}

auto SwitchPersistence::loadConfiguration(const std::string& filename) -> bool {
    std::scoped_lock lock(persistence_mutex_);
    try {
        if (!validateConfigFile(filename)) {
            spdlog::error("[SwitchPersistence] Invalid configuration file: {}",
                          filename);
            return false;
        }
        // In a real implementation, this would load configuration from JSON/XML
        std::ifstream file(filename);
        if (!file.is_open()) {
            spdlog::error(
                "[SwitchPersistence] Failed to open file for reading: {}",
                filename);
            return false;
        }
        file.close();
        spdlog::info("[SwitchPersistence] Configuration loaded from: {}",
                     filename);
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to load configuration: {}",
                      ex.what());
        return false;
    }
}

// Auto-save functionality
auto SwitchPersistence::enableAutoSave(bool enable) -> bool {
    std::scoped_lock lock(persistence_mutex_);
    auto_save_enabled_ = enable;
    spdlog::info("[SwitchPersistence] Auto-save {}",
                 enable ? "enabled" : "disabled");
    return true;
}

auto SwitchPersistence::isAutoSaveEnabled() -> bool {
    std::scoped_lock lock(persistence_mutex_);
    return auto_save_enabled_;
}

void SwitchPersistence::setAutoSaveInterval(uint32_t intervalSeconds) {
    std::scoped_lock lock(persistence_mutex_);
    auto_save_interval_ = intervalSeconds;
    spdlog::info("[SwitchPersistence] Auto-save interval set to: {} seconds",
                 intervalSeconds);
}

// Internal methods
auto SwitchPersistence::getDefaultConfigPath() -> std::string {
    // In a real implementation, this would use system-specific paths
    return std::string("./lithium_switch_config.json");
}

auto SwitchPersistence::createBackup(const std::string& filename) -> bool {
    try {
        std::string backupName = filename + ".backup";
        std::filesystem::copy_file(
            filename, backupName,
            std::filesystem::copy_options::overwrite_existing);
        spdlog::info("[SwitchPersistence] Created backup: {}", backupName);
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to create backup: {}",
                      ex.what());
        return false;
    }
}

auto SwitchPersistence::validateConfigFile(const std::string& filename)
    -> bool {
    try {
        if (!std::filesystem::exists(filename)) {
            spdlog::error(
                "[SwitchPersistence] Configuration file does not exist: {}",
                filename);
            return false;
        }
        if (std::filesystem::file_size(filename) == 0) {
            spdlog::error("[SwitchPersistence] Configuration file is empty: {}",
                          filename);
            return false;
        }
        // In a real implementation, this would validate JSON/XML structure
        return true;
    } catch (const std::exception& ex) {
        spdlog::error("[SwitchPersistence] Failed to validate config file: {}",
                      ex.what());
        return false;
    }
}
